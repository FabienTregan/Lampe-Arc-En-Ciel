#include "ftFind.ulp"
#include "ftPolar.ulp"

string CMD_PLACE = "place";
string CMD_ROWS = "rows";
string CMD_CAPS = "caps";
string CMD_SEGMENTS = "segments";
string CMD_RIPUP = "ripup";
string CMD_TEST = "test";
 
string PIN_DI  = "1";
string PIN_CI  = "2";
string PIN_GND = "3";
string PIN_VCC = "4";
string PIN_CO  = "5";
string PIN_DO  = "6";

int NB_SEGMENTS = 3;
int NB_ROWS = 4;
int ROW_WIDTH = 10;                           // Width of each row in mm
real ARC_ANGLE = 90;                          // 90 for half a rainbow, 180 for normal rainbow
real SEGMENT_ANGLE = ARC_ANGLE / NB_SEGMENTS;
real OUTER_RADIUS = 100;                      // Outer diameter of the pcb
real CAP_MARGIN = 5;                          // Distance between cap and led in mm
real WIDTH = 0.5;                             // Wires width
real INNER_RADIUS = OUTER_RADIUS - ROW_WIDTH * NB_ROWS;

real angleToCenter(real x, real y) {
  return atan((y - 0) / (x - OUTER_RADIUS)) * 180 / PI;
}

string ledName(int n) {
  string result;
  sprintf(result, "LED%d", n);
  return result;
}

string capName(int n) {
  string result;
  sprintf(result, "C%d", n);
  return result;
}

UL_ELEMENT findLed(int n) {
  return findElement(ledName(n));
}

UL_ELEMENT findCap(int n) {
  return findElement(capName(n));
}

string wirePads(UL_CONTACT cFrom, UL_CONTACT cTo) {
  string line;
  sprintf(line, "ROUTE %f (%f %f) (%f %f);", WIDTH, u2mm(cFrom.x), u2mm(cFrom.y), u2mm(cTo.x), u2mm(cTo.y));
  return line;
}

string markCenter(void) {
  string line;
  sprintf(line, "MARK (%f 0);\n", OUTER_RADIUS);
  return line;
}

string connectRows(void) {
  string result = "SET OBSTACLE_MODE IGNORE; SET WIRE_BEND 2;\n";
  for (int segment = 0; segment < NB_SEGMENTS; segment++){
    for (int row = 0; row < NB_ROWS - 1; row++) {

      int n = (1 + segment * NB_ROWS + row); 

      UL_ELEMENT eLedFrom = findLed(n);
      UL_ELEMENT eLedTo = findLed(n + 1);

      UL_CONTACT cCO = findContact(eLedFrom, PIN_CO);
      UL_CONTACT cDO = findContact(eLedFrom, PIN_DO);
      UL_CONTACT cCI = findContact(eLedTo,   PIN_CI);
      UL_CONTACT cDI = findContact(eLedTo,   PIN_DI);

      result += wirePads(cCO, cCI);
      result += wirePads(cDO, cDI);

    }
  }
  return result;
}

string connectSegments(void) {
  string result = "CHANG WIDTH 0.5;";
  for (int segment = 0; segment < NB_SEGMENTS -1; segment++){

    int n = (1 + segment) * NB_ROWS;

    UL_ELEMENT ledFrom = findLed(n);
    UL_ELEMENT ledTo = findLed(n + 1);

    UL_CONTACT cDO= findContact(ledFrom, PIN_DO);
    UL_CONTACT cDI= findContact(ledTo, PIN_DI);

    result +=
      ftpStartFromContact(OUTER_RADIUS, 0, cDO)
      + ftpRadialMoveTo(OUTER_RADIUS - 0.85)
      + ftpAngularMove(-(SEGMENT_ANGLE / 3 + 1.25))
      + ftpRadialMoveToContact(cDI)
      + ftpAngularMoveToContact(cDI);

    UL_CONTACT cCO = findContact(ledFrom, PIN_CO);
    UL_CONTACT cCI = findContact(ledTo, PIN_CI);

    result +=
      ftpStartFromContact(OUTER_RADIUS, 0, cCO)
      + ftpRadialMoveTo(OUTER_RADIUS - 1.65)
      + ftpAngularMove(-(SEGMENT_ANGLE/3 - 1.25))
      + ftpRadialMoveTo(INNER_RADIUS + 1)
      + ftpAngularMoveToContact(cCI)
      + ftpRadialMoveToContact(cCI)
      + ftpEnd();
  } 

  return result;
}

string connectCaps(void) {
  string result = "";

  for (int segment = 0; segment < NB_SEGMENTS; segment++){
    for (int row = 0; row < NB_ROWS; row++) {
      int n = (1 + segment * NB_ROWS + row);

      UL_ELEMENT eLed = findLed(n);
      UL_ELEMENT eCap = findCap(n);

      UL_CONTACT cGND  = findContact(eLed, PIN_GND);
      UL_CONTACT cVCC  = findContact(eLed, PIN_VCC);
      UL_CONTACT cCap1 = findContact(eCap, "1");
      UL_CONTACT cCap2 = findContact(eCap, "2");

      result +=
        ftpStartFromContact(OUTER_RADIUS, 0, cGND)
        + ftpAngularMoveToContact(cCap2)
        + ftpRadialMoveToContact(cCap2)

        + ftpStartFromContact(OUTER_RADIUS, 0, cVCC)
        + ftpAngularMoveToContact(cCap1)
        + ftpRadialMoveToContact(cCap1);
    }
  }

  for (segment = 0; segment < NB_SEGMENTS; segment++){
    for(int row = 0; row < NB_ROWS; row++) {
      int n = segment * NB_ROWS + row + 1;

      UL_ELEMENT eCap = findCap(n);

      real goodSideAngle = SEGMENT_ANGLE * (segment + 0.5) + 6;

      UL_CONTACT cGoodSide;
      UL_CONTACT cWrongSide;
      real wrongSideAngle;
      real goodSideDistance;
      real wrongSideViaRadius;

      if(row < 2) {
        cGoodSide = findContact(eCap, "1");
        cWrongSide = findContact(eCap, "2");
        wrongSideAngle = goodSideAngle + 0.40;
        goodSideDistance = +2;
        wrongSideViaRadius = INNER_RADIUS + ROW_WIDTH * NB_ROWS / 2 + 0.5;
      } else {
        cGoodSide = findContact(eCap, "2");
        cWrongSide = findContact(eCap, "1");
        wrongSideAngle = goodSideAngle + 1.0;
        wrongSideViaRadius = INNER_RADIUS + ROW_WIDTH * NB_ROWS / 2 - 0.5;
        goodSideDistance = -2;
      }

      result +=
        ftpStartFromContact(OUTER_RADIUS, 0, cWrongSide)
        + ftpAngularMoveTo(180 - wrongSideAngle);
      if(row == 0 || row == (NB_ROWS-1)) {
        result +=
          ftpRadialMoveTo(wrongSideViaRadius)
          + ftpVia();
      }

      result +=
        ftpStartFromContact(OUTER_RADIUS, 0, cGoodSide)
        + ftpRadialMove(goodSideDistance)
        + ftpVia();
    }
  }

  result += ftpEnd();

  return result;
}

string place(void) {
  string result;
  string line;

  result = markCenter(); 

  for (int segment = 0; segment < NB_SEGMENTS; segment++){
    for (int row = 0; row < NB_ROWS; row++) {

      int n = (1 + segment * NB_ROWS + row); 

      string ledN = ledName(n);
      string capN = capName(n);
      
      real angle = SEGMENT_ANGLE * (segment + 0.5);
      real radius = OUTER_RADIUS - (NB_ROWS - 0.5 - row) * ROW_WIDTH;

      sprintf(line, "MOVE %s (P %f %f); ROTATE =R%f %s;\n", ledN, radius, 180 - angle, 180 - angle, ledN);
      result += line;

      angle = angle + 6 - radius / 30;

      sprintf(line, "MOVE %s (P %f %f); ROTATE =R%f %s;\n", capN, radius, 180 - angle , - angle, capN);
      result += line;
    }
  }

   return result;
}


void main() {
  string script;

  // This hack allows to execute each script before executing the next one.
  // This allows the parts to be positionned by previous script before the next one is executed.
  if(argc == 1) {
    script = "run laec.ulp " + CMD_PLACE + ";";
    script += "run laec.ulp " + CMD_ROWS + ";";
    script += "run laec.ulp " + CMD_CAPS + ";";
    script += "run laec.ulp " + CMD_SEGMENTS + ";";
  } else if (argv[1] == CMD_PLACE) {
    script = place();
  } else if (argv[1] == CMD_ROWS) {
    script = connectRows();
  } else if (argv[1] == CMD_CAPS) {
    script = connectCaps();
  } else if (argv[1] == CMD_SEGMENTS) {
    script = connectSegments();
  } else if (argv[1] == CMD_TEST) {
  }

  exit(script);
}